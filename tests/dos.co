W i386/16 Core 
W stack I nip M 46 46 I drop M ad I dup M 4e 4e 89 04 
W numeric I lit G dup M b8 Y i16 I + M 03 04 G nip I - M 93 ad 29 d8 I 1+ M 40 I 1- M 48    
W logic I and M 23 04 G nip I or M 0b 04 G nip I xor M 33 04 G nip I rol M 51 91 ad d3 c0 59 
W branch I jmp M e9 M 00 00  I jnz M 75 00  I jz M 74 00 I jns M 79 00  I js M 78 00  I test M 85 c0 
W flow I call M e8 00 00  I ; M c3  I hlt M F4 
W memory I ! M 93 ad 89 07 ad I @ M 93 8b 07  


W Language implementation
I -if G test jns Y ip@ 1 - G drop Y ; I if G test jz Y ip@  1 - ; 
I then Y dup 1 + ip@ swap - swap i! G drop Y ; 
I for M 51 91 G drop Y ip@
I next M e2 Y ip@ - 1 - i8 M 59 Y ;


W i386/16/DOS COM Binary Format
Y 2 sections I text Y 1 section I data Y 2 section ;
Y $100 dup text base ! text ptr !
Y $400 dup data base ! data ptr !

I i8 Y text w8 Y ;
I i16 Y text w16 Y ;
I ip Y text ptr I Y I ip@ Y ip @ I ip! Y ip ! ;
I dp Y data ptr I Y I dp@ Y dp @ I dp! Y dp ! ;

I compile Y W store Y ip@ W touchup Y placeholder Y ip! G main ; W restore Y ip!
W calculate padding Y data base @ ip@ - text base @ - 
W make binary Y text write padding data write ;


W i386/16/DOS Runtime
R init W setup data stack M be 00 e8 G R placeholder G jmp W to main defined later
I int21h M cd 21 G drop Y ; 
R emit M 92 b4 02 G int21h ; R space G $20 emit ; R cr G $d $a emit emit ;
R puts M 92 b4 09 G int21h ; R hexchar G dup 10 - -if $30 + ; then $37 + ;
R . G 4 for G 4 rol dup $f and hexchar emit next G drop ;


W User code: incrementally test some language features
R main
R test1 G 49 emit space
R test2 G 50 2 for dup emit space 1+ next drop
R test3 G $4567 dup . space
R test4 G 2 for $4444 + dup . space next drop cr
R test5 G 65 13 for 2 for dup emit 1+ next next cr
R test6 G $FEDC P a G ! $7654 P c G ! $3210 P d G ! $BA98 P b G ! d c b a 4 for @ . next cr
R test7 G "pizza$" puts cr 
R test8 G "pizza$" P pizza G ! pizza @ puts cr ; 


