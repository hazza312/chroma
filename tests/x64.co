W x64/Linux/ELF ---------------------------------------------------------------
Y 2 sections little endian I binary Y 0 I code Y 1 I data Y 2 ;

I vma-load Y $028000 I elf-head-size Y $40 I phead-size Y $38
I code-file-offset Y phead-size 2 * elf-head-size + 
I code-load-start Y vma-load code-file-offset + ;
I code-size Y code ptr @ code base @ -
I b64 Y binary w64 Y ;

Y code-load-start code base ! Y code-load-start code ptr !

I compile
Y 0 magic!

W ELF headers M
M 7f 45 4c 46 W magic
M 02 01 01 00 W 64-bit, little endian, version, system v
M 00 00 00 00 00 00 00 00 W abi version, padding 
M 02 00 3e 00 W shared object, amd x86-64
M 01 00 00 00 W version 
Y main b64 W entry point
M 40 00 00 00 00 00 00 00 W program header start
M 00 00 00 00 00 00 00 00 W section header start (not included)
M 00 00 00 00 W architecture flags (none?)
M 40 00 W size this header
M 38 00 W size of program header entry
M 02 00 W number of entries in program header table
M 00 00 W size of a section header table entry
M 00 00 W number of section header entries
M 00 00 W index in section header with section names

W Program header -- code
M 01 00 00 00 W loadable segment
M 05 00 00 00 W not writeable (bit0=X, bit1=W, bit2=R)
Y 00 b64 W segment offset in file image
Y vma-load b64 W VA of segment in memory
Y vma-load b64 W physical address
Y code-size b64 W size of segment bytes in file image
Y code-size b64 W size of segment bytes in memory
M 00 00 20 00 00 00 00 00 W alignment

W Program header -- data
M 01 00 00 00 W loadable segment
M 06 00 00 00 W flags  (bit0=X, bit1=W, bit2=R)
M 00 00 00 00 00 00 00 00 W segment offset in file image
Y vma-load $100000 + b64 W VA of segment in memory
Y vma-load $100000 + b64 W physical address
M 00 00 00 00 00 00 00 00 W size of segment bytes in file image
Y $1000 b64 W size of segment bytes in memory
Y $1000 b64 W alignment
Y code write Y ;


W x64/Linux/Core --------------------------------------------------------------
Y code magic!
I ip@ Y code ptr @ I i32 Y code w32 I i8 Y code w8

I swap M 48 8b 1e 48 89 06 48 93 Y ;
I dup M 4c 29 fe 48 89 06 I drop M 48 ad I nip M 4c 01 fe
I lit G dup M b8 Y code w32
I ; M c3
I jmp Y code ptr @ - 5 - M e9 Y i32 ; 
I call Y code ptr @ - 5 - M e8 Y i32 ;
I + M 48 93 G drop M 48 01 d8 
I - M 48 93 G drop M 48 29 d8
I test M 48 85 c0 G drop
I if G test M 0f 84 Y ip@ M 00 00 00 00
I then Y dup 1 + ip@ 3 - swap - swap i32!

I for M 51 48 91 48 ad Y ip@ ;
I next Y dup ip@ - 2 - M e2 Y i8 M 59 Y ;

I str Y ;
I and Y ;
I shr Y ;


W Runtime --------------------------------------------------------------------- 
R emit G dup M 51 b8 01 00 00 00 bf 01 00 00 00 ba 01 00 00 00 0f 05 59 G drop drop G ;
R space G $20 emit ; R cr G $0a emit ; R exit M bf 3c 00 00 00 48 97 0f 05 G ;
R hexdigit G dup $a - -if $31 + ; then $41 + ;
R .H G dup $f0 and 4 shr hexdigit emit $0f and hexdigit emit ;


W User Program   --------------------------------------------------------------
R chars W from num G for dup emit 1 + next ; 

R main 
R init W r15=8 M 41 bf 08 00 00 00 W init rsi stack top M be 00 90 12 00 
G $30 10 chars W , G $41 26 chars cr 0 exit



